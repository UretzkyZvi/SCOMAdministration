<?xml version="1.0" encoding="utf-8"?>
<ManagementPack SchemaVersion="2.0" ContentReadable="true" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <Manifest>
    <Identity>
      <ID>SCOMAdministrationAddOns</ID>
      <Version>1.0.0.0</Version>
    </Identity>
    <Name>SCOM.Administration.AddOns</Name>
    <References>
      <Reference Alias="SC">
        <ID>Microsoft.SystemCenter.Library</ID>
        <Version>7.0.8433.0</Version>
        <PublicKeyToken>31bf3856ad364e35</PublicKeyToken>
      </Reference>
      <Reference Alias="Windows">
        <ID>Microsoft.Windows.Library</ID>
        <Version>7.5.8501.0</Version>
        <PublicKeyToken>31bf3856ad364e35</PublicKeyToken>
      </Reference>
      <Reference Alias="System">
        <ID>System.Library</ID>
        <Version>7.5.8501.0</Version>
        <PublicKeyToken>31bf3856ad364e35</PublicKeyToken>
      </Reference>
    </References>
  </Manifest>
  <TypeDefinitions>
    <ModuleTypes>
      <ConditionDetectionModuleType ID="Event.LinkedDataMapper" Comment="Maps an event to a Entity Linked Event" Accessibility="Internal" Batching="false" Stateful="false" PassThrough="false">
        <Configuration>
          <xsd:element name="ManagedEntityId" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="RuleId" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <ModuleImplementation Isolation="Any">
          <Native>
            <ClassID>eae677d0-9d4f-11d9-9669-0800200c9a66</ClassID>
          </Native>
        </ModuleImplementation>
        <OutputType>SC!Microsoft.SystemCenter.Event.LinkedData</OutputType>
        <InputTypes>
          <InputType>System!System.Event.Data</InputType>
        </InputTypes>
      </ConditionDetectionModuleType>
      <WriteActionModuleType Accessibility="Public" ID="HealthServicesPingCheck">
        <Configuration>
          <xsd:element name="NetBIOSName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="PrincipalName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="ManagementServerName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="PingSamples" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="IntervalMilliseconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="TimeoutSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <OverrideableParameters>
          <OverrideableParameter ID="NetBIOSName" Selector="$Config/NetBIOSName$" ParameterType="string" />
          <OverrideableParameter ID="PrincipalName" Selector="$Config/PrincipalName$" ParameterType="string" />
          <OverrideableParameter ID="ManagementServerName" Selector="$Config/ManagementServerName$" ParameterType="string" />
          <OverrideableParameter ID="PingSamples" Selector="$Config/PingSamples$" ParameterType="int" />
          <OverrideableParameter ID="IntervalMilliseconds" Selector="$Config/IntervalMilliseconds$" ParameterType="int" />
          <OverrideableParameter ID="TimeoutSeconds" Selector="$Config/TimeoutSeconds$" ParameterType="int" />
        </OverrideableParameters>
        <ModuleImplementation Isolation="Any">
          <Composite>
            <MemberModules>
              <ProbeAction TypeID="Windows!Microsoft.Windows.PowerShellPropertyBagProbe" ID="PSScript">
                <ScriptName>HealthServicesPingCheck.ps1</ScriptName>
                <ScriptBody><![CDATA[#=================================================================================
#  Script to ping check via PowerShell
#
# This script will use Get-WmiObject command to check ping status 
# Takes a single parameter of a Health Service Computer Name FQDN
# Will be executed from Health Service primary management server.
# v 1.0
#=================================================================================

param($NetBIOSName,$PrincipalName,$ManagementServerName,$PingSamples,$intervalMilliseconds)
$scomapi = new-object -comObject "MOM.ScriptAPI"

If ($PrincipalName.Trim() -eq ""){
$PrincipalName="."
}


$stateCodes=@{}
$stateCodes.Add(0,"Success");
$stateCodes.Add(14,"Bad address");
$stateCodes.Add(11001,"Buffer Too Small");
$stateCodes.Add(11002,"Destination Net Unreachable");
$stateCodes.Add(11003,"Destination Host Unreachable");
$stateCodes.Add(11004,"Destination Protocol Unreachable");
$stateCodes.Add(11005,"Destination Port Unreachable");
$stateCodes.Add(11006,"No Resources");
$stateCodes.Add(11007,"Bad Option");
$stateCodes.Add(11008,"Hardware Error");
$stateCodes.Add(11009,"Packet Too Big");
$stateCodes.Add(11010,"Request Timed Out");
$stateCodes.Add(11011,"Bad Request");
$stateCodes.Add(11012,"Bad Route");
$stateCodes.Add(11013,"TimeToLive Expired Transit");
$stateCodes.Add(11014,"TimeToLive Expired Reassembly");
$stateCodes.Add(11015,"Parameter Problem");
$stateCodes.Add(11016,"Source Quench");
$stateCodes.Add(11017,"Option Too Big");
$stateCodes.Add(11018,"Bad Destination");
$stateCodes.Add(11032,"Negotiating IPSEC");
$stateCodes.Add(11050,"General Failure");

$Query = "SELECT PrimaryAddressResolutionStatus,StatusCode, ResponseTime FROM Win32_PingStatus WHERE Address = '$PrincipalName'"

for($i=1;$i -le $PingSamples;$i++)
{
    $oStatus = get-wmiobject -Query $Query -ComputerName $ManagementServerName 

    if ($oStatus.PrimaryAddressResolutionStatus -ne 0)
    {
		$Query = "SELECT PrimaryAddressResolutionStatus,StatusCode, ResponseTime FROM Win32_PingStatus WHERE Address = '$NetBIOSName'"

		$oStatus = get-wmiobject -Query $Query -ComputerName $ManagementServerName

		if ($oStatus.PrimaryAddressResolutionStatus -ne 0)
		{
			$StatusCode=14
			$ResponseTime=0
			break
		} 
		else{
			$StatusCode=$oStatus.StatusCode
			$ResponseTime=$oStatus.ResponseTime
			if($StatusCode -eq 0) {break}
			if($StatusCode -ne $null)
			{
				$StatusCode=11003
				$ResponseTime=0
			}
		}
    }
	else{
			$StatusCode=$oStatus.StatusCode
			$ResponseTime=$oStatus.ResponseTime
			if($StatusCode -eq 0) {break}
			if($StatusCode -ne $null)
			{
				$StatusCode=11003
				$ResponseTime=0
			}
		}
		Start-Sleep -m $intervalMilliseconds
}
$scompb = $scomapi.CreatePropertyBag()
$scompb.AddValue("Status", $stateCodes.Item([Int]$StatusCode))
$scompb.AddValue("StatusCode",$StatusCode)
$scompb.AddValue("ResponseTime",$ResponseTime)
$scompb.AddValue("AgentServerName",$PrincipalName)
$scompb.AddValue("ManagementServerName",$ManagementServerName)
$scompb
]]></ScriptBody>
                <Parameters>
                  <Parameter>
                    <Name>NetBIOSName</Name>
                    <Value>$Config/NetBIOSName$</Value>
                  </Parameter>
                  <Parameter>
                    <Name>PrincipalName</Name>
                    <Value>$Config/PrincipalName$</Value>
                  </Parameter>
                  <Parameter>
                    <Name>ManagementServerName</Name>
                    <Value>$Config/ManagementServerName$</Value>
                  </Parameter>
                  <Parameter>
                    <Name>PingSamples</Name>
                    <Value>$Config/PingSamples$</Value>
                  </Parameter>
                  <Parameter>
                    <Name>IntervalMilliseconds</Name>
                    <Value>$Config/IntervalMilliseconds$</Value>
                  </Parameter>
                </Parameters>
                <TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
              </ProbeAction>
              <ConditionDetection ID="Mapper" TypeID="System!System.Event.GenericDataMapper">
                <EventOriginId>$Target/Id$</EventOriginId>
                <PublisherId>$MPElement$</PublisherId>
                <PublisherName>ServerConnectivityCheck</PublisherName>
                <Channel>Application</Channel>
                <LoggingComputer>$Data/Property[@Name='ManagementServerName']$</LoggingComputer>
                <EventNumber>100</EventNumber>
                <EventCategory>3</EventCategory>
                <EventLevel>0</EventLevel>
                <UserName />
                <Params>
                  <Param>$Data/Property[@Name='Status']$</Param>
                  <Param>$Data/Property[@Name='StatusCode']$</Param>
                  <Param>$Data/Property[@Name='ResponseTime']$</Param>
                  <Param>$Data/Property[@Name='AgentServerName']$</Param>
                  <Param>$Data/Property[@Name='ManagementServerName']$</Param>
                </Params>
              </ConditionDetection>
              <ConditionDetection TypeID="Event.LinkedDataMapper" ID="LinkedDataMapper">
                <ManagedEntityId>$Target/Id$</ManagedEntityId>
                <RuleId>$MPElement$</RuleId>
              </ConditionDetection>
              <WriteAction TypeID="SC!Microsoft.SystemCenter.CollectEvent" ID="EventWA" />
            </MemberModules>
            <Composition>
              <Node ID="EventWA">
                <Node ID="LinkedDataMapper">
                  <Node ID="Mapper">
                    <Node ID="PSScript" />
                  </Node>
                </Node>
              </Node>
            </Composition>
          </Composite>
        </ModuleImplementation>
        <InputType>System!System.BaseData</InputType>
      </WriteActionModuleType>
      <WriteActionModuleType Accessibility="Public" ID="HealthServicesNoHeartbeat">
        <Configuration>
          <xsd:element name="InMaintenance" minOccurs="0" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="TimeoutSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <OverrideableParameters>
          <OverrideableParameter ID="InMaintenance" ParameterType="int" Selector="$Config/InMaintenance$" />
          <OverrideableParameter ID="TimeoutSeconds" ParameterType="int" Selector="$Config/TimeoutSeconds$" />
        </OverrideableParameters>
        <ModuleImplementation>
          <Composite>
            <MemberModules>
              <WriteAction ID="WR" TypeID="Windows!Microsoft.Windows.PowerShellWriteAction">
                <ScriptName>HealthServicesNoHeartbeat.ps1</ScriptName>
                <ScriptBody><![CDATA[#=================================================================================
#  Script to collect unhealthy HealthService agents via PowerShell
#
# This script will query OperationsManager db.
# Takes a single parameter of inMM it mean if too return unhealthy agent include in maintenance mode agent or not (0 not , 1 include)
# For each health service ping status will be executed check ping task that executed from agent primary management server
# v 1.0
#=================================================================================
param([int]$InMM=0)

$SCRIPT_EVENT_ID = 5210 
$SCRIPT_NAME = "HealthServicesNoPerformanceData.ps1"
Set-StrictMode -Version 1

#Event Severity values
$INFORMATION_EVENT_TYPE = 0
$ERROR_EVENT_TYPE = 1 

$api = New-Object -comObject "MOM.ScriptAPI"

#helper function to get registry value 
function GetValueProperty($value)
{
	try{
		 $key = "HKLM:\SOFTWARE\Microsoft\Microsoft Operations Manager\3.0\Setup\"
		(Get-ItemProperty $key $value).$value
	}
	catch{
		msg = "Error occurred!{0}Computer:{1}{0}Reason: {2}" -f [Environment]::NewLine, $env:COMPUTERNAME, $_.Exception.Message
		$api.LogScriptEvent($SCRIPT_NAME, $SCRIPT_EVENT_ID, $ERROR_EVENT_TYPE, $msg)
	}	
}



Function Import-GlobalTaskCmdlets()
{

	$SCOMPowerShellKey = "HKLM:\SOFTWARE\Microsoft\System Center Operations Manager\12\Setup\Powershell\V2"
	$SCOMModulePath = (Get-ItemProperty $SCOMPowerShellKey).InstallDirectory

    if ($true -eq [string]::IsNullOrEmpty($SCOMModulePath))
    {
        $ErrorMessage = "Path to SCOM cmdlets not found in registry."
		msg = "Error occurred!{0}Computer:{1}{0}Reason: {2}" -f [Environment]::NewLine, $env:COMPUTERNAME, $ErrorMessage
		$api.LogScriptEvent($SCRIPT_NAME, $SCRIPT_EVENT_ID, $ERROR_EVENT_TYPE, $msg)
		exit 
    }   

    $SCOMModulePath = Join-Path $SCOMModulePath "OperationsManager"   

	try
	{
							   
			Import-module $SCOMModulePath
							   
	}
	catch [System.IO.FileNotFoundException]
	{
		$ErrorMessage = "SCOM cmdlets do not exist."
		msg = "Error occurred!{0}Computer:{1}{0}Reason: {2}" -f [Environment]::NewLine, $env:COMPUTERNAME, $ErrorMessage
		$api.LogScriptEvent($SCRIPT_NAME, $SCRIPT_EVENT_ID, $ERROR_EVENT_TYPE, $msg)
		exit 
	}
	catch
	{
            $ErrorMessage = $_.Exception.Message
           	msg = "Error occurred!{0}Computer:{1}{0}Reason: {2}" -f [Environment]::NewLine, $env:COMPUTERNAME, $ErrorMessage
			$api.LogScriptEvent($SCRIPT_NAME, $SCRIPT_EVENT_ID, $ERROR_EVENT_TYPE, $msg)
			exit
	}
					   

}

Import-GlobalTaskCmdlets

$SQLServer = GetValueProperty("DatabaseServerName")
$SQLDBName = GetValueProperty("DatabaseName")

$SqlQuery = @"
/* List of all health services without heartbeat 
 Monitor Id of Health Service Heartbeat Failure
 */
SELECT
	 SourceBME.BaseManagedEntityId HealthServiceID
	,TargetBME.BaseManagedEntityId ManagementServerID
	,SourceBME.DisplayName AS HealthServiceFQDN
	,LEFT(SourceBME.DisplayName,CHARINDEX('.',SourceBME.DisplayName)-1) AS HealthServiceMachineName
	,TargetBME.DisplayName AS ManagementServer
FROM Relationship R WITH (NOLOCK)
JOIN (SELECT
		hs.BaseManagedEntityId
		,hs.DisplayName
	FROM State s
	LEFT JOIN MaintenanceMode mm
		ON s.BaseManagedEntityId = mm.BaseManagedEntityId
	JOIN (SELECT BaseManagedEntityId ,Name FROM BaseManagedEntity WHERE BaseManagedTypeId = 'A4899740-EF2F-1541-6C1D-51D34B739491') bme
		ON bme.BaseManagedEntityId = s.BaseManagedEntityId
	JOIN MTV_HealthService hs
		ON hs.BaseManagedEntityId = bme.Name
	WHERE MonitorId = 'B59F78CE-C42A-8995-F099-E705DBB34FD4'
	AND HealthState <> 1
	AND (mm.IsInMaintenanceMode = $($InMM)
	OR mm.BaseManagedEntityId IS NULL) AND hs.IsAgent=1) SourceBME
	ON R.SourceEntityID = SourceBME.BaseManagedEntityID
JOIN BaseManagedEntity TargetBME
	ON R.TargetEntityID = TargetBME.BaseManagedEntityID
WHERE R.RelationshipTypeId = dbo.fn_ManagedTypeId_MicrosoftSystemCenterHealthServiceCommunication()
"@

$SQLConn = New-Object System.Data.SqlClient.SqlConnection
$SQLConn.ConnectionString = "Server = $SQLServer; Database = $SQLDBName; Integrated Security = True"
$SqlCmd = New-Object System.Data.SqlClient.SqlCommand
$SqlCmd.CommandText = $SqlQuery
$SqlCmd.Connection = $SQLConn
$SqlAdapter = New-Object System.Data.SqlClient.SqlDataAdapter
$SqlAdapter.SelectCommand = $SqlCmd
$DS = New-Object System.Data.DataSet
$SqlAdapter.Fill($DS)
$SQLConn.Close()

try
{
	$TaskPing = Get-SCOMTask -Name SCOMAdministrationAddOns.HealthServicesPingCheckTask
	Foreach($row in $DS.Tables[0].Rows){

		$MSInstance = Get-SCOMClassInstance -Id $row["ManagementServerID"]

		$override=@{NetBIOSName=$row["HealthServiceMachineName"]; PrincipalName=$row["HealthServiceFQDN"] }

		$task_run=Start-SCOMTask -Task $TaskPing -Instance $MSInstance -Override $override 
	}
}	
catch
{
        $ErrorMessage = $_.Exception.Message
        msg = "Error occurred!{0}Computer:{1}{0}Reason: {2}" -f [Environment]::NewLine, $env:COMPUTERNAME, $ErrorMessage
		$api.LogScriptEvent($SCRIPT_NAME, $SCRIPT_EVENT_ID, $ERROR_EVENT_TYPE, $msg)
		exit
}
]]></ScriptBody>
                <Parameters>
                  <Parameter>
                    <Name>InMM</Name>
                    <Value>$Config/InMaintenance$</Value>
                  </Parameter>
                </Parameters>
                <TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
              </WriteAction>
            </MemberModules>
            <Composition>
              <Node ID="WR" />
            </Composition>
          </Composite>
        </ModuleImplementation>
        <InputType>System!System.BaseData</InputType>
      </WriteActionModuleType>
      <WriteActionModuleType Accessibility="Public" ID="HealthServicesNoPerformanceDataRecovery">
        <Configuration>
          <xsd:element name="TimeoutSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <OverrideableParameters>
          <OverrideableParameter ID="TimeoutSeconds" ParameterType="int" Selector="$Config/TimeoutSeconds$" />
        </OverrideableParameters>
        <ModuleImplementation>
          <Composite>
            <MemberModules>
              <WriteAction ID="WR" TypeID="Windows!Microsoft.Windows.PowerShellWriteAction">
                <ScriptName>HealthServicesNoPerformanceData.ps1</ScriptName>
                <ScriptBody><![CDATA[#=================================================================================
#  Script to collect unhealthy HealthService agents via PowerShell
#
# This script will query OperationsManager db.
# Takes a single parameter of inMM it mean if too return unhealthy agent include in maintenance mode agent or not (0 not , 1 include)
# For each health service ping status will be executed check ping task that executed from agent primary management server
# v 1.0
#=================================================================================
param()

$SCRIPT_EVENT_ID = 5220 
$SCRIPT_NAME = "HealthServicesNoPerformanceData.ps1"
Set-StrictMode -Version 1

#Event Severity values
$INFORMATION_EVENT_TYPE = 0
$ERROR_EVENT_TYPE = 1 

$api = New-Object -comObject "MOM.ScriptAPI"

#helper function to get registry value 
function GetValueProperty($value)
{
	try{
		 $key = "HKLM:\SOFTWARE\Microsoft\Microsoft Operations Manager\3.0\Setup\"
		(Get-ItemProperty $key $value).$value
	}
	catch{
		msg = "Error occurred!{0}Computer:{1}{0}Reason: {2}" -f [Environment]::NewLine, $env:COMPUTERNAME, $_.Exception.Message
		$api.LogScriptEvent($SCRIPT_NAME, $SCRIPT_EVENT_ID, $ERROR_EVENT_TYPE, $msg)
	}	
}



Function Import-GlobalTaskCmdlets()
{

	$SCOMPowerShellKey = "HKLM:\SOFTWARE\Microsoft\System Center Operations Manager\12\Setup\Powershell\V2"
	$SCOMModulePath = (Get-ItemProperty $SCOMPowerShellKey).InstallDirectory

    if ($true -eq [string]::IsNullOrEmpty($SCOMModulePath))
    {
        $ErrorMessage = "Path to SCOM cmdlets not found in registry."
		msg = "Error occurred!{0}Computer:{1}{0}Reason: {2}" -f [Environment]::NewLine, $env:COMPUTERNAME, $ErrorMessage
		$api.LogScriptEvent($SCRIPT_NAME, $SCRIPT_EVENT_ID, $ERROR_EVENT_TYPE, $msg)
		exit 
    }   

    $SCOMModulePath = Join-Path $SCOMModulePath "OperationsManager"   

	try
	{
							   
			Import-module $SCOMModulePath
							   
	}
	catch [System.IO.FileNotFoundException]
	{
		$ErrorMessage = "SCOM cmdlets do not exist."
		msg = "Error occurred!{0}Computer:{1}{0}Reason: {2}" -f [Environment]::NewLine, $env:COMPUTERNAME, $ErrorMessage
		$api.LogScriptEvent($SCRIPT_NAME, $SCRIPT_EVENT_ID, $ERROR_EVENT_TYPE, $msg)
		exit 
	}
	catch
	{
            $ErrorMessage = $_.Exception.Message
           	msg = "Error occurred!{0}Computer:{1}{0}Reason: {2}" -f [Environment]::NewLine, $env:COMPUTERNAME, $ErrorMessage
			$api.LogScriptEvent($SCRIPT_NAME, $SCRIPT_EVENT_ID, $ERROR_EVENT_TYPE, $msg)
			exit
	}
					   

}

Import-GlobalTaskCmdlets

$SQLServer = GetValueProperty("DatabaseServerName")
$SQLDBName = GetValueProperty("DatabaseName")

$SqlQuery = @"
SELECT
	* INTO #tmp
FROM dbo.PerformanceDataAllView P
WHERE P.TimeSampled > DATEADD(hour, -12, GETUTCDATE())

SELECT
	C.*
   ,ME.Path
   ,me.IsDeleted INTO #tmp1
FROM dbo.ManagedEntityGenericView ME
INNER JOIN dbo.ManagedTypeView MT
	ON ME.MonitoringClassId = MT.Id
		AND MT.Name = 'Microsoft.SystemCenter.HealthService'
INNER JOIN MaintenanceMode MM
	ON MM.BaseManagedEntityId = ME.Id
		AND MM.IsInMaintenanceMode = 0
LEFT JOIN dbo.PerformanceCounterView C
	ON ME.Id = C.ManagedEntityId
WHERE ME.IsDeleted = 0


SELECT
	*
FROM (SELECT
		c.Path
	   ,c.ManagedEntityId
	   ,CAST(MAX(p.TimeSampled) AS NVARCHAR(50)) AS 'LastSample'
	FROM #tmp1 C
	JOIN State s
		ON s.BaseManagedEntityId = c.ManagedEntityId
	LEFT JOIN #tmp P
		ON C.PerformanceSourceInternalId = P.PerformanceSourceInternalId
	GROUP BY c.Path
			,ManagedEntityId) a
WHERE a.LastSample IS NULL
AND Path NOT IN (SELECT
		hs.DisplayName
	FROM State s
	LEFT JOIN MaintenanceMode mm
		ON s.BaseManagedEntityId = mm.BaseManagedEntityId
	JOIN (SELECT
			BaseManagedEntityId
		   ,Name
		FROM BaseManagedEntity
		WHERE BaseManagedTypeId = 'A4899740-EF2F-1541-6C1D-51D34B739491') bme
		ON bme.BaseManagedEntityId = s.BaseManagedEntityId
	JOIN MTV_HealthService hs
		ON hs.BaseManagedEntityId = bme.Name
	WHERE MonitorId = 'B59F78CE-C42A-8995-F099-E705DBB34FD4'
	AND HealthState <> 1
	AND (mm.IsInMaintenanceMode = 0
	OR mm.BaseManagedEntityId IS NULL)
	AND hs.IsAgent = 1)


DROP TABLE #tmp
DROP TABLE #tmp1
"@

$SQLConn = New-Object System.Data.SqlClient.SqlConnection
$SQLConn.ConnectionString = "Server = $SQLServer; Database = $SQLDBName; Integrated Security = True"
$SqlCmd = New-Object System.Data.SqlClient.SqlCommand
$SqlCmd.CommandText = $SqlQuery
$SqlCmd.Connection = $SQLConn
$SqlAdapter = New-Object System.Data.SqlClient.SqlDataAdapter
$SqlAdapter.SelectCommand = $SqlCmd
$DS = New-Object System.Data.DataSet
$SqlAdapter.Fill($DS)
$SQLConn.Close()

try
{
	$Task= Get-SCOMTask -Name Microsoft.SystemCenter.ResetHealthServiceStore
	Foreach($row in $DS.Tables[0].Rows){

		$MSInstance = Get-SCOMClassInstance -Id $row["ManagedEntityId"]
		$task_run=Start-SCOMTask -Task $TaskPi -Instance $MSInstance 
	}
}	
catch
{
        $ErrorMessage = $_.Exception.Message
        msg = "Error occurred!{0}Computer:{1}{0}Reason: {2}" -f [Environment]::NewLine, $env:COMPUTERNAME, $ErrorMessage
		$api.LogScriptEvent($SCRIPT_NAME, $SCRIPT_EVENT_ID, $ERROR_EVENT_TYPE, $msg)
		exit
}
]]></ScriptBody>
                <TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
              </WriteAction>
            </MemberModules>
            <Composition>
              <Node ID="WR" />
            </Composition>
          </Composite>
        </ModuleImplementation>
        <InputType>System!System.BaseData</InputType>
      </WriteActionModuleType>
      <WriteActionModuleType Accessibility="Public" ID="HealthServicesAnalyzeAndRepair">
        <Configuration>
          <xsd:element name="LastSamplesIntervalInMinutes" minOccurs="0" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="TimeoutSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <OverrideableParameters>
          <OverrideableParameter ID="LastSamplesIntervalInMinutes" ParameterType="int" Selector="$Config/LastSamplesIntervalInMinutes$" />
          <OverrideableParameter ID="TimeoutSeconds" ParameterType="int" Selector="$Config/TimeoutSeconds$" />
        </OverrideableParameters>
        <ModuleImplementation>
          <Composite>
            <MemberModules>
              <WriteAction ID="WR" TypeID="Windows!Microsoft.Windows.PowerShellWriteAction">
                <ScriptName>GetUnhealthyAgents.ps1</ScriptName>
                <ScriptBody><![CDATA[#=================================================================================
#  Script to analyze health service status and based on status repair the agent via PowerShell
#
# This script will query OperationsManager db.
# Takes a single parameter of time in minutes to get last ping sample, should be around 5 minutes by default.
# since by default ping check sample take every 5 minutes.
# Will be executed all management servers pool.
# For each health service ping status will be executed task
# if ping status equal 0 then restart agent
# if ping status equal 14 (Bad Address) delete agent
# v 1.0
#=================================================================================

param( [int]$LastSamplesIntervalInMinutes = 5)

$SCRIPT_EVENT_ID = 5211
$SCRIPT_NAME = "HealthServicesAnalyzeAndRepair.ps1"
Set-StrictMode -Version 1
#Event Severity values
$INFORMATION_EVENT_TYPE = 0
$ERROR_EVENT_TYPE = 1 


$api = New-Object -comObject "MOM.ScriptAPI"
#helper function to get registry value 
function GetValueProperty($value)
{
	try{
		 $key = "HKLM:\SOFTWARE\Microsoft\Microsoft Operations Manager\3.0\Setup\"
		(Get-ItemProperty $key $value).$value
	}
	catch{
		msg = "Error occurred!{0}Computer:{1}{0}Reason: {2}" -f [Environment]::NewLine, $env:COMPUTERNAME, $_.Exception.Message
		$api.LogScriptEvent($SCRIPT_NAME, $SCRIPT_EVENT_ID, $ERROR_EVENT_TYPE, $msg)
	}	
}



Function Import-GlobalTaskCmdlets()
{

	$SCOMPowerShellKey = "HKLM:\SOFTWARE\Microsoft\System Center Operations Manager\12\Setup\Powershell\V2"
	$SCOMModulePath = (Get-ItemProperty $SCOMPowerShellKey).InstallDirectory

    if ($true -eq [string]::IsNullOrEmpty($SCOMModulePath))
    {
        $ErrorMessage = "Path to SCOM cmdlets not found in registry."
		msg = "Error occurred!{0}Computer:{1}{0}Reason: {2}" -f [Environment]::NewLine, $env:COMPUTERNAME, $ErrorMessage
		$api.LogScriptEvent($SCRIPT_NAME, $SCRIPT_EVENT_ID, $ERROR_EVENT_TYPE, $msg)
		exit 
    }   

    $SCOMModulePath = Join-Path $SCOMModulePath "OperationsManager"   

	try
	{
							   
			Import-module $SCOMModulePath
							   
	}
	catch [System.IO.FileNotFoundException]
	{
		$ErrorMessage = "SCOM cmdlets do not exist."
		msg = "Error occurred!{0}Computer:{1}{0}Reason: {2}" -f [Environment]::NewLine, $env:COMPUTERNAME, $ErrorMessage
		$api.LogScriptEvent($SCRIPT_NAME, $SCRIPT_EVENT_ID, $ERROR_EVENT_TYPE, $msg)
		exit 
	}
	catch
	{
            $ErrorMessage = $_.Exception.Message
           	msg = "Error occurred!{0}Computer:{1}{0}Reason: {2}" -f [Environment]::NewLine, $env:COMPUTERNAME, $ErrorMessage
			$api.LogScriptEvent($SCRIPT_NAME, $SCRIPT_EVENT_ID, $ERROR_EVENT_TYPE, $msg)
			exit
	}
					   

}

Import-GlobalTaskCmdlets


$SQLServer = GetValueProperty("DatabaseServerName")
$SQLDBName = GetValueProperty("DatabaseName")

$SqlQuery = @"
SELECT
	tb.StatusCode
   ,tb.AgentServerName
   ,tb.ManagementServerName
   ,d.HealthServiceFQDN
   ,d.HealthServiceID
   ,d.ManagementServer
   ,d.ManagementServerID
FROM (SELECT
		ROW_NUMBER() OVER (PARTITION BY AgentServerName ORDER BY AgentServerName) RN
	   ,Status
	   ,StatusCode
	   ,ResponseTime
	   ,AgentServerName
	   ,ManagementServerName
	   ,TimeGenerated
	   ,DATEADD(MINUTE, ((DATEPART(MINUTE, TimeGenerated) / 5) * 5), DATEADD(HOUR, DATEDIFF(HOUR, 0, TimeGenerated), 0)) AS TimeGeneratedFixed
	FROM EventAllView
	OUTER APPLY (SELECT
			CAST(EventParameters AS XML) AS EventParametersXML) x
	OUTER APPLY (SELECT
			x.value('Param[1]', 'VARCHAR(80)') AS Status
		   ,x.value('Param[2]', 'VARCHAR(80)') AS StatusCode
		   ,x.value('Param[3]', 'VARCHAR(80)') AS ResponseTime
		   ,x.value('Param[4]', 'VARCHAR(80)') AS AgentServerName
		   ,x.value('Param[5]', 'VARCHAR(80)') AS ManagementServerName
		FROM x.EventParametersXML.nodes('/') AS NodeValues (x)) y
	WHERE PublisherName = 'ServerConnectivityCheck'
	AND DATEADD(MINUTE, ((DATEPART(MINUTE, TimeGenerated) / 5) * 5), DATEADD(HOUR, DATEDIFF(HOUR, 0, TimeGenerated), 0)) > 
	
	DATEADD(MINUTE, ((DATEPART(MINUTE, TimeGenerated) / 5) * 5) - $($LastSamplesIntervalInMinutes), DATEADD(HOUR, DATEDIFF(HOUR, 0, TimeGenerated), 0))
) AS tb
JOIN (SELECT
		SourceBME.BaseManagedEntityId HealthServiceID
	   ,TargetBME.BaseManagedEntityId ManagementServerID
	   ,SourceBME.DisplayName AS HealthServiceFQDN
	   ,LEFT(SourceBME.DisplayName, CHARINDEX('.', SourceBME.DisplayName) - 1) AS HealthServiceMachineName
	   ,TargetBME.DisplayName AS ManagementServer
	FROM Relationship R WITH (NOLOCK)
	JOIN (SELECT
			hs.BaseManagedEntityId
		   ,hs.DisplayName
		FROM State s
		LEFT JOIN MaintenanceMode mm
			ON s.BaseManagedEntityId = mm.BaseManagedEntityId
		JOIN (SELECT BaseManagedEntityId ,Name FROM BaseManagedEntity WHERE BaseManagedTypeId = 'A4899740-EF2F-1541-6C1D-51D34B739491') bme
			ON bme.BaseManagedEntityId = s.BaseManagedEntityId
		JOIN MTV_HealthService hs
			ON hs.BaseManagedEntityId = bme.Name
		WHERE MonitorId = 'B59F78CE-C42A-8995-F099-E705DBB34FD4'
		AND HealthState <> 1
		AND (mm.IsInMaintenanceMode = 0
		OR mm.BaseManagedEntityId IS NULL) AND hs.IsAgent=1 ) SourceBME
		ON R.SourceEntityID = SourceBME.BaseManagedEntityID
	JOIN BaseManagedEntity TargetBME
		ON R.TargetEntityID = TargetBME.BaseManagedEntityID
	WHERE R.RelationshipTypeId = dbo.fn_ManagedTypeId_MicrosoftSystemCenterHealthServiceCommunication()) d
	ON d.HealthServiceFQDN = tb.AgentServerName 
WHERE tb.RN = 1
"@

$SQLConn = New-Object System.Data.SqlClient.SqlConnection
$SQLConn.ConnectionString = "Server = $SQLServer; Database = $SQLDBName; Integrated Security = True"
$SqlCmd = New-Object System.Data.SqlClient.SqlCommand
$SqlCmd.CommandText = $SqlQuery
$SqlCmd.Connection = $SQLConn
$SqlAdapter = New-Object System.Data.SqlClient.SqlDataAdapter
$SqlAdapter.SelectCommand = $SqlCmd
$DS = New-Object System.Data.DataSet
$SqlAdapter.Fill($DS)
$SQLConn.Close()

try
{
	Foreach($row in $DS.Tables[0].Rows){
		if($row["StatusCode"] -eq 0)
		{
			# the machine answer to ping, it mean restart to agent
			$TaskRestart = Get-SCOMTask -Name SCOMAdministrationAddOns.RestartHealthServiceTask

			$MSInstance = Get-SCOMClassInstance -Id $row["ManagementServerID"]

			$override=@{HealthServiceAgentName=$row["HealthServiceFQDN"]}

			$task_run=Start-SCOMTask -Task $TaskRestart -Instance $MSInstance -Override $override
		}
		if ($row["StatusCode"] -eq 14){
			# the machine have a bad address, it mean the server account in AD was deleted
			$TaskDeleteAgent = Get-SCOMTask -Name SCOMAdministrationAddOns.DeleteHealthServiceTask

			$objIPProperties = [System.Net.NetworkInformation.IPGlobalProperties]::GetIPGlobalProperties()
			$servername ="{0}.{1}" -f $objIPProperties.HostName, $objIPProperties.DomainName
			$class = Get-SCOMClass -Name Microsoft.SystemCenter.ManagementServer
			$MSInstance =  Get-SCOMClassInstance -Class $class | ?{$_.displayname -eq $servername }
		    
			$override=@{AgentName=$row["HealthServiceFQDN"]}

			$task_run=Start-SCOMTask -Task $TaskDeleteAgent -Instance $MSInstance -Override $override
		}
	}
}	
catch
{
        $ErrorMessage = $_.Exception.Message
        msg = "Error occurred!{0}Computer:{1}{0}Reason: {2}" -f [Environment]::NewLine, $env:COMPUTERNAME, $ErrorMessage
		$api.LogScriptEvent($SCRIPT_NAME, $SCRIPT_EVENT_ID, $ERROR_EVENT_TYPE, $msg)
		exit
}
]]></ScriptBody>
                <Parameters>
                  <Parameter>
                    <Name>LastSamplesIntervalInMinutes</Name>
                    <Value>$Config/LastSamplesIntervalInMinutes$</Value>
                  </Parameter>
                </Parameters>
                <TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
              </WriteAction>
            </MemberModules>
            <Composition>
              <Node ID="WR" />
            </Composition>
          </Composite>
        </ModuleImplementation>
        <InputType>System!System.BaseData</InputType>
      </WriteActionModuleType>
      <WriteActionModuleType Accessibility="Public" ID="HealthServiceRestartFromManagementServer">
        <Configuration>
          <xsd:element name="HealthServiceAgentName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <OverrideableParameters>
          <OverrideableParameter ID="HealthServiceAgentName" Selector="$Config/HealthServiceAgentName$" ParameterType="string" />
        </OverrideableParameters>
        <ModuleImplementation Isolation="Any">
          <Composite>
            <MemberModules>
              <WriteAction ID="PSScript" TypeID="Windows!Microsoft.Windows.PowerShellWriteAction">
                <ScriptName>HealthServiceRestartFromManagementServer.ps1</ScriptName>
                <ScriptBody><![CDATA[#=================================================================================
#  Script to restart HealthService agent via PowerShell
#
# This script will use Get-WmiObject command to check ping status and stop, start HealthService service
# Takes a single parameter of a Health Service Computer Name FQDN
# Will be executed from Health Service primary management server.
#
# v 1.0
#=================================================================================
Param($HealthServiceName)


$pingstate = Get-WmiObject -Query "select * from win32_pingstatus where address='$($HealthServiceName)'"

if($pingstate.StatusCode -eq $null -or $pingstate.StatusCode -ne 0)
{
	write-host "No ping response from agent."
}
else
{
    $Error.Clear()
    try{

	  $service = Get-WmiObject -Query "SELECT * FROM Win32_Service WHERE name = 'HealthService'" -computerName $HealthServiceName  -ErrorAction Stop
    }
    catch
    {
		$err = $Error[0]
		write-host $err.Exception.Message
	    break
    }

	$rt = $service.stopService()
	$i=0
	while ($service.State -eq "Running" -and $i -le 6)
	{
		Start-Sleep -m 10000
		$i=$i+1
		$service = Get-WmiObject -Query "SELECT * FROM Win32_Service WHERE name = 'HealthService'" -computerName $HealthServiceName
	}

	if($service.State -ne "Stopped")
	{
	 write-host "Failed to stop: Terminating..."
	 $process = Get-WmiObject -Query "SELECT * FROM Win32_process WHERE ProcessId = '$($service.ProcessId)'"
	$rt = $process.Terminate()
	 $service = Get-WmiObject -Query "SELECT * FROM Win32_Service WHERE name = 'HealthService'" -computerName $HealthServiceName
	}
	$rt = $service.StartService()
	$i=0
	while ($service.State -ne "Running" -and $i -le 6)
	{
		Start-Sleep -m 10000
		$i=$i+1
		$service = Get-WmiObject -Query "SELECT * FROM Win32_Service WHERE name = 'HealthService'" -computerName $HealthServiceName
	}
	if($service.State -eq "Running" -and $i -eq 0)
	{
		write-host "Failed to stop, last state:$($service.State)"
	}
	if($service.State -ne "Running" )
	{
		write-host "Failed to start, last state:$($service.State)"
	}
	if($service.State -eq "Running" -and $i -le 6)
	{
		write-host "Restarted Successfully"
	}
}]]></ScriptBody>
                <Parameters>
                  <Parameter>
                    <Name>HealthServiceName</Name>
                    <Value>$Config/HealthServiceAgentName$</Value>
                  </Parameter>
                </Parameters>
                <TimeoutSeconds>300</TimeoutSeconds>
              </WriteAction>
            </MemberModules>
            <Composition>
              <Node ID="PSScript" />
            </Composition>
          </Composite>
        </ModuleImplementation>
        <OutputType>Windows!Microsoft.Windows.SerializedObjectData</OutputType>
        <InputType>System!System.BaseData</InputType>
      </WriteActionModuleType>
      <WriteActionModuleType Accessibility="Public" ID="DeleteHealthService">
        <Configuration>
          <xsd:element minOccurs="1" name="AgentName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <OverrideableParameters>
          <OverrideableParameter ID="AgentName" Selector="$Config/AgentName$" ParameterType="string" />
        </OverrideableParameters>
        <ModuleImplementation Isolation="Any">
          <Composite>
            <MemberModules>
              <WriteAction ID="PSScript" TypeID="Windows!Microsoft.Windows.PowerShellWriteAction">
                <ScriptName>DeleteHealthService.ps1</ScriptName>
                <ScriptBody><![CDATA[#=================================================================================
#  Script to delete agents via PowerShell
#
# This script will delete agents using the SDK binaries and .NET based SDK commands
# Takes a single parameter of a computer FQDN
# Should be run on a management server
#
# v 1.0
#=================================================================================
param($AgentName)

# For testing manually in PowerShell:
# $AgentName = 'WS2012.opsmgr.net'

#=================================================================================
# Constants section - modify stuff here:

# Assign script name variable for use in event logging
$ScriptName = "DeleteHealthService.ps1"
#=================================================================================

# Gather script start time
$StartTime = Get-Date

# Gather who the script is running as
$whoami = whoami

#Load the MOMScript API and discovery property bag
$momapi = New-Object -comObject "Mom.ScriptAPI"

#Log script event that we are starting task
$momapi.LogScriptEvent($ScriptName,1016,0, "Starting script.  AgentName is ($AgentName).  Running as ($whoami)")

# Begin Main Script
#=================================================================================
# Get SCOM directory for binaries
$SCOMRegKey = "HKLM:\SOFTWARE\Microsoft\Microsoft Operations Manager\3.0\Setup"
$SCOMPath = (Get-ItemProperty $SCOMRegKey).InstallDirectory
$SCOMPath = $SCOMPath.TrimEnd("\")
$SCOMSDKPath = "$SCOMPath\SDK Binaries"

#Load SDK binaries
$dummy = [System.Reflection.Assembly]::LoadFrom("$SCOMSDKPath\Microsoft.EnterpriseManagement.Core.dll")
$dummy = [System.Reflection.Assembly]::LoadFrom("$SCOMSDKPath\Microsoft.EnterpriseManagement.OperationsManager.dll")
$dummy = [System.Reflection.Assembly]::LoadFrom("$SCOMSDKPath\Microsoft.EnterpriseManagement.Runtime.dll")

# Connect to management group
$MG = [Microsoft.EnterpriseManagement.ManagementGroup]::Connect($Env:COMPUTERNAME)
$Admin = $MG.GetAdministration()

# Define generic collection list which is required parameter for the SDK delete command
$AgentManagedComputerType = [Microsoft.EnterpriseManagement.Administration.AgentManagedComputer];
$GenericListType = [System.Collections.Generic.List``1]
$GenericList = $GenericListType.MakeGenericType($AgentManagedComputerType)
$AMCList = new-object $GenericList.FullName

# Get the AgentManagedComputer from the name in the most efficient way possible
# This SDK method does not require the performance hit of Get-SCOMAgent or looping through each agent to find the right one
Write-Host "Getting agent details for agent: ($AgentName)"
$query = "Name= '$AgentName'"
$AgentCriteria = New-Object Microsoft.EnterpriseManagement.Administration.AgentManagedComputerCriteria($query)
$Agent = ($Admin.GetAgentManagedComputers($AgentCriteria))[0]
$AgentCount = $Agent.Count

# Log messages to console
IF ($AgentCount -eq 1)
{
  $AgentDisplayName = $Agent.DisplayName
  Write-Host "Found agent: ($AgentDisplayName)"
}
ELSE
{
  Write-Host "ERROR: An Agent with name ($AgentName) not found!"
  Write-Host "Terminating"
  $momapi.LogScriptEvent($ScriptName,1016,2,"`n ERROR: Agent not found with agent name ($AgentName).  Terminating script")
  EXIT
}

# Add our agent to the collection
$AMCList.Add($Agent)

# Delete the agent in the collection
Write-Host "Deleting Agent"
$Admin.DeleteAgentManagedComputers($AMCList)
Write-Host "Agent Deleted"
#=================================================================================
# End Main Script


# Log an event for script ending and total execution time.
$EndTime = Get-Date
$ScriptTime = ($EndTime - $StartTime).TotalSeconds
$momapi.LogScriptEvent($ScriptName,1016,0,"`n Script has completed. `n Deleted ($AgentName).  Runtime is ($ScriptTime)")]]></ScriptBody>
                <Parameters>
                  <Parameter>
                    <Name>AgentName</Name>
                    <Value>$Config/AgentName$</Value>
                  </Parameter>
                </Parameters>
                <TimeoutSeconds>300</TimeoutSeconds>
              </WriteAction>
            </MemberModules>
            <Composition>
              <Node ID="PSScript" />
            </Composition>
          </Composite>
        </ModuleImplementation>
        <OutputType>Windows!Microsoft.Windows.SerializedObjectData</OutputType>
        <InputType>System!System.BaseData</InputType>
      </WriteActionModuleType>
    </ModuleTypes>
  </TypeDefinitions>
  <Monitoring>
    <Rules>
      <Rule ID="SCOMAdministrationAddOns.HealthServicesNoHeartbeatRule" Target="SC!Microsoft.SystemCenter.AllManagementServersPool" Enabled="true" ConfirmDelivery="false" Remotable="true" Priority="Normal" DiscardLevel="100">
        <Category>Maintenance</Category>
        <DataSources>
          <DataSource ID="DS" TypeID="System!System.SimpleScheduler">
            <IntervalSeconds>300</IntervalSeconds>
            <SyncTime />
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="WA" TypeID="HealthServicesNoHeartbeat">
            <InMaintenance>0</InMaintenance>
            <TimeoutSeconds>300</TimeoutSeconds>
          </WriteAction>
        </WriteActions>
      </Rule>
      <Rule ID="SCOMAdministrationAddOns.HealthServicesAnalyzeAndRepairRule" Target="SC!Microsoft.SystemCenter.AllManagementServersPool" Enabled="true" ConfirmDelivery="false" Remotable="true" Priority="Normal" DiscardLevel="100">
        <Category>Maintenance</Category>
        <DataSources>
          <DataSource ID="DS" TypeID="System!System.SimpleScheduler">
            <IntervalSeconds>43200</IntervalSeconds>
            <SyncTime>00:02</SyncTime>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="WA" TypeID="HealthServicesAnalyzeAndRepair">
            <LastSamplesIntervalInMinutes>7</LastSamplesIntervalInMinutes>
            <TimeoutSeconds>300</TimeoutSeconds>
          </WriteAction>
        </WriteActions>
      </Rule>
      <Rule ID="SCOMAdministrationAddOns.HealthServicesNoPerformanceDataRecoveryRule" Target="SC!Microsoft.SystemCenter.AllManagementServersPool" Enabled="true" ConfirmDelivery="false" Remotable="true" Priority="Normal" DiscardLevel="100">
        <Category>Maintenance</Category>
        <DataSources>
          <DataSource ID="DS" TypeID="System!System.SimpleScheduler">
            <IntervalSeconds>43200</IntervalSeconds>
            <SyncTime />
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="WA" TypeID="HealthServicesNoPerformanceDataRecovery">
            <TimeoutSeconds>300</TimeoutSeconds>
          </WriteAction>
        </WriteActions>
      </Rule>
    </Rules>
    <Tasks>
      <Task ID="SCOMAdministrationAddOns.RestartHealthServiceTask" Accessibility="Internal" Target="SC!Microsoft.SystemCenter.ManagementServer" Enabled="true" Timeout="300" Remotable="true">
        <Category>Maintenance</Category>
        <WriteAction ID="WA" TypeID="HealthServiceRestartFromManagementServer">
          <HealthServiceAgentName>.</HealthServiceAgentName>
        </WriteAction>
      </Task>
      <Task ID="SCOMAdministrationAddOns.DeleteHealthServiceTask" Accessibility="Internal" Target="SC!Microsoft.SystemCenter.ManagementServer" Enabled="true" Timeout="300" Remotable="true">
        <Category>Maintenance</Category>
        <WriteAction ID="WA" TypeID="DeleteHealthService">
          <AgentName>.</AgentName>
        </WriteAction>
      </Task>
      <Task ID="SCOMAdministrationAddOns.HealthServicesPingCheckTask" Accessibility="Internal" Target="SC!Microsoft.SystemCenter.ManagementServer" Enabled="true" Timeout="300" Remotable="true">
        <Category>Maintenance</Category>
        <WriteAction ID="WA" TypeID="HealthServicesPingCheck" Target="SC!Microsoft.SystemCenter.CollectionManagementServer">
          <NetBIOSName>.</NetBIOSName>
          <PrincipalName>.</PrincipalName>
          <ManagementServerName>$Target/Property[Type="SC!Microsoft.SystemCenter.HealthService"]/AuthenticationName$</ManagementServerName>
          <PingSamples>3</PingSamples>
          <IntervalMilliseconds>30000</IntervalMilliseconds>
          <TimeoutSeconds>300</TimeoutSeconds>
        </WriteAction>
      </Task>
    </Tasks>
  </Monitoring>
  <LanguagePacks>
    <LanguagePack ID="ENU" IsDefault="true">
      <DisplayStrings>
        <DisplayString ElementID="SCOMAdministrationAddOns">
          <Name>SCOM.Administration.AddOns</Name>
          <Description>SCOM Administration AddOns</Description>
        </DisplayString>
        <DisplayString ElementID="SCOMAdministrationAddOns.HealthServicesNoHeartbeatRule">
          <Name>Health Services without heartbeat collection</Name>
          <Description>Description for the new rule</Description>
        </DisplayString>
        <DisplayString ElementID="SCOMAdministrationAddOns.HealthServicesAnalyzeAndRepairRule">
          <Name>Health Services Analyze And Repair</Name>
          <Description>Description for the new rule</Description>
        </DisplayString>
        <DisplayString ElementID="SCOMAdministrationAddOns.HealthServicesNoPerformanceDataRecoveryRule">
          <Name>Health Services No Performance Data Recovery Rule</Name>
          <Description>Description for the new rule</Description>
        </DisplayString>
        <DisplayString ElementID="SCOMAdministrationAddOns.RestartHealthServiceTask">
          <Name>Restart Health Service (SCOM administration addon)</Name>
          <Description>Description for the new agent task.</Description>
        </DisplayString>
        <DisplayString ElementID="SCOMAdministrationAddOns.DeleteHealthServiceTask">
          <Name>Delete Health Service (SCOM administration addon)</Name>
          <Description>Description for the new agent task.</Description>
        </DisplayString>
        <DisplayString ElementID="SCOMAdministrationAddOns.HealthServicesPingCheckTask">
          <Name>Health Services Ping Check (SCOM administration addon)</Name>
          <Description>Description for the new agent task.</Description>
        </DisplayString>
      </DisplayStrings>
      <KnowledgeArticles></KnowledgeArticles>
    </LanguagePack>
  </LanguagePacks>
</ManagementPack>